#ifndef __COLLISION_FXI__
#define __COLLISION_FXI__


static const uint COLLISION_INTERSECT	= 0; 
static const uint COLLISION_INSIDE 		= 1; 
static const uint COLLISION_OUTSIDE 	= 2; 


/*------------------------------------------------------------------------------
	Frustum / AABB intersection
------------------------------------------------------------------------------*/

uint FrustumAABBIntersect( float4 planes[6], float3 mins, float3 maxs )
{
	float3 vmin, vmax; 
	uint ret = COLLISION_INSIDE;
	
	// X axis 
	for (int i=0; i<6; i++) 
	{
		float4 plane = planes[i];
		
		if(plane.x > 0) { 
			vmin.x = mins.x; 
			vmax.x = maxs.x; 
		} else { 
			vmin.x = maxs.x; 
			vmax.x = mins.x; 
		} 
		// Y axis 
		if(plane.y > 0) { 
			vmin.y = mins.y; 
			vmax.y = maxs.y; 
		} else { 
			vmin.y = maxs.y; 
			vmax.y = mins.y; 
		} 
		// Z axis 
		if(plane.z > 0) { 
			vmin.z = mins.z; 
			vmax.z = maxs.z; 
		} else { 
			vmin.z = maxs.z; 
			vmax.z = mins.z; 
		} 
		
		if (dot(plane.xyz, vmin) + plane.w > 0) return COLLISION_OUTSIDE;
		if (dot(plane.xyz, vmax) + plane.w >= 0) ret = COLLISION_INTERSECT;
	}
	return ret;
}

bool IsAABBOutsidePlane( float4 plane, float3 mins, float3 maxs )
{
	float3 vmin, vmax; 
	// X axis 
	if(plane.x > 0) { 
		vmin.x = mins.x; 
		vmax.x = maxs.x; 
	} else { 
		vmin.x = maxs.x; 
		vmax.x = mins.x; 
	} 
	// Y axis 
	if(plane.y > 0) { 
		vmin.y = mins.y; 
		vmax.y = maxs.y; 
	} else { 
		vmin.y = maxs.y; 
		vmax.y = mins.y; 
	} 
	// Z axis 
	if(plane.z > 0) { 
		vmin.z = mins.z; 
		vmax.z = maxs.z; 
	} else { 
		vmin.z = maxs.z; 
		vmax.z = mins.z; 
	} 
	return (dot(plane.xyz, vmin) + plane.w > 0);
}


float4 NormalizePlane( float4 plane )
{
	float len = length(plane.xyz);
	return plane / len;
}

void GetPlanesForMatrix ( float4x4 vpMatrix, out float4 planes[6] )
{
	float4 left, right, top, bottom, near, far;

	// Left plane
	left.x = vpMatrix._14 + vpMatrix._11;
	left.y = vpMatrix._24 + vpMatrix._21;
	left.z = vpMatrix._34 + vpMatrix._31;
	left.w = vpMatrix._44 + vpMatrix._41;
	left = NormalizePlane(left);

	// right plane
	right.x = vpMatrix._14 - vpMatrix._11;
	right.y = vpMatrix._24 - vpMatrix._21;
	right.z = vpMatrix._34 - vpMatrix._31;
	right.w = vpMatrix._44 - vpMatrix._41;
	right = NormalizePlane(right);

	// top plane
	top.x = vpMatrix._14 - vpMatrix._12;
	top.y = vpMatrix._24 - vpMatrix._22;
	top.z = vpMatrix._34 - vpMatrix._32;
	top.w = vpMatrix._44 - vpMatrix._42;
	top = NormalizePlane(top);

	// bottom plane
	bottom.x = vpMatrix._14 + vpMatrix._12;
	bottom.y = vpMatrix._24 + vpMatrix._22;
	bottom.z = vpMatrix._34 + vpMatrix._32;
	bottom.w = vpMatrix._44 + vpMatrix._42;
	bottom = NormalizePlane(bottom);

	// near plane
	near.x = vpMatrix._13;
	near.y = vpMatrix._23;
	near.z = vpMatrix._33;
	near.w = vpMatrix._43;
	near = NormalizePlane(near);

	// far plane
	far.x = vpMatrix._14 - vpMatrix._13;
	far.y = vpMatrix._24 - vpMatrix._23;
	far.z = vpMatrix._34 - vpMatrix._33;
	far.w = vpMatrix._44 - vpMatrix._43;
	far = NormalizePlane(far);
	
	planes[0]	=	left;
	planes[1] 	=	right;
	planes[2]	=	top;
	planes[3] 	=	bottom;
	planes[4]	=	near;
	planes[5] 	=	far;
}


/*------------------------------------------------------------------------------
	Ray
------------------------------------------------------------------------------*/

struct RAY
{
	float3 orig;
	float3 invdir;
	float3 dir;
	// int3   dirsign;
};


RAY ConstructRay( float3 origin, float3 dir )
{
	RAY r;
	r.orig		=	origin;
	r.dir		=	dir;
	r.invdir	=	1.0f / dir;
	// r.dirsign.x	=	( dir.x < 0 ) ? 1 : 0;
	// r.dirsign.y	=	( dir.y < 0 ) ? 1 : 0;
	// r.dirsign.z	=	( dir.z < 0 ) ? 1 : 0;
	return r;
}


/*------------------------------------------------------------------------------
	Ray / AABB intersection
------------------------------------------------------------------------------*/

void swap(inout float a, inout float b)
{
	float t = a;
	a = b;
	b = t;
}


//
//	https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection
//
bool RayAABBIntersection(RAY r, float3 aabbMin, float3 aabbMax, out float tmin, out float tmax) 
{ 
	#if 1
		tmin = (aabbMin.x - r.orig.x) * r.invdir.x; 
		tmax = (aabbMax.x - r.orig.x) * r.invdir.x; 
	 
		if (tmin > tmax) swap(tmin, tmax); 
	 
		float tymin = (aabbMin.y - r.orig.y) * r.invdir.y; 
		float tymax = (aabbMax.y - r.orig.y) * r.invdir.y; 
	 
		if (tymin > tymax) swap(tymin, tymax); 
	 
		if ((tmin > tymax) || (tymin > tmax)) 
			return false; 
	 
		if (tymin > tmin) 
			tmin = tymin; 
	 
		if (tymax < tmax) 
			tmax = tymax; 
	 
		float tzmin = (aabbMin.z - r.orig.z) * r.invdir.z; 
		float tzmax = (aabbMax.z - r.orig.z) * r.invdir.z; 
	 
		if (tzmin > tzmax) swap(tzmin, tzmax); 
	 
		if ((tmin > tzmax) || (tzmin > tmax)) 
			return false; 
	 
		if (tzmin > tmin) 
			tmin = tzmin; 
	 
		if (tzmax < tmax) 
			tmax = tzmax; 
	 
		return true; 
	#else
		tmin = (aabbMin.x - r.orig.x) / r.dir.x; 
		tmax = (aabbMax.x - r.orig.x) / r.dir.x; 
	 
		if (tmin > tmax) swap(tmin, tmax); 
	 
		float tymin = (aabbMin.y - r.orig.y) / r.dir.y; 
		float tymax = (aabbMax.y - r.orig.y) / r.dir.y; 
	 
		if (tymin > tymax) swap(tymin, tymax); 
	 
		if ((tmin > tymax) || (tymin > tmax)) 
			return false; 
	 
		if (tymin > tmin) 
			tmin = tymin; 
	 
		if (tymax < tmax) 
			tmax = tymax; 
	 
		float tzmin = (aabbMin.z - r.orig.z) / r.dir.z; 
		float tzmax = (aabbMax.z - r.orig.z) / r.dir.z; 
	 
		if (tzmin > tzmax) swap(tzmin, tzmax); 
	 
		if ((tmin > tzmax) || (tzmin > tmax)) 
			return false; 
	 
		if (tzmin > tmin) 
			tmin = tzmin; 
	 
		if (tzmax < tmax) 
			tmax = tzmax; 
	 
		return true; 
	#endif
} 


/*------------------------------------------------------------------------------
	Ray / Triangle intersection
------------------------------------------------------------------------------*/

#define EPSILON 0.00001

float3 Barycentric(float3 p, float3 a, float3 b, float3 c )
{
    float3 v0 = b - a; 
	float3 v1 = c - a; 
	float3 v2 = p - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0f - v - w;
	return float3(u,v,w);
}

bool RayTriangleIntersection( RAY r, float3 a, float3 b, float3 c, float4 plane, out float t, out float2 uv )
{
	t = 0;
	uv = float2(0,0);
	
	// 	ray and triangle are parallel 
	//	or ray comes from behind:
	if ( dot(r.dir, plane.xyz) > EPSILON )
	{
		return false;
	}
	
	t = - (plane.w + dot(r.orig, plane.xyz)) / dot(r.dir, plane.xyz);
	
	if (t<0)
	{
		return false;
	}

	float3 p 	=	r.orig + r.dir * t;
	
	uv = Barycentric( p, a, b, c ).xy;
	
	if (uv.x<0 || uv.y<0 || uv.x + uv.y>1 )
	{
		return false;
	}
	
	return true;
}







#endif






