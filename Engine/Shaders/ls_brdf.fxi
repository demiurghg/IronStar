#ifndef __LS_BRDF_FXI__
#define __LS_BRDF_FXI__

#include "math.fxi"

/*------------------------------------------------------------------------------
	BRDF structures :
------------------------------------------------------------------------------*/

struct FLUX
{
	float3	intensity;		//	light intensity by R,G,B components
	float3	direction;		//	light flux direction, opposite to direction to light, normalized
	float	divergency;		//	light divergency to approximate finite size lights
	float3	direction1;		//	light flux direction, opposite to direction to light, normalized
	float	divergency1;	//	light divergency to approximate finite size lights
};

struct SURFACE
{
	float3	baseColor;		//	base color or albedo
	float3	normal;			//	world-space normal of the surface in given point
	float3 	emission;		//	emissive lighting component
	
	float	roughness;		//	roughness
	float	metallic;		//	metallic
	float	occlusion;		//	ambient occlusion factor
	
	float3	diffuse;		//	[derived] call ComputeDiffuseSpecular to recalc
	float3	specular;		//	[derived] call ComputeDiffuseSpecular to recalc

	float	alpha;			//	Alpha transparency
};

struct MEDIUM
{
	float3	Color;
};

struct GEOMETRY
{
	float3	position;		//	world-space position
	float3 	normal;			//	world-space geometry (vertex interpolated) normal
};

SURFACE CreateDiffuseSurface(float3 color, float3 normal)
{
	SURFACE surf;
	surf.baseColor	=	color;
	surf.normal		=	normal;
	surf.emission	=	0;	
	surf.roughness	=	1;	
	surf.metallic	=	0;	
	surf.occlusion	=	1;	
	surf.diffuse	=	color;
	surf.specular	=	0;	
	surf.alpha		=	1;	
	return surf;
}

GEOMETRY CreateGeometry( float3 p, float3 n )
{
	GEOMETRY g;
	g.position 	= p;
	g.normal	= n;
	return g;
}

float ClampRoughness( float r )
{
	return clamp( r, 1.0f / 16.0f, 1 );
}

/*------------------------------------------------------------------------------
	BRDF functions :
------------------------------------------------------------------------------*/

float3	Lambert( float3 intensity, float3 diff_color )
{
	return intensity * diff_color / PI;
}


/*-----------------------------------------------------------------------------
	Fresnel :
-----------------------------------------------------------------------------*/

float3	Fresnel( float c, float3 Fn )
{
	//	values below 2% are not physically possible.
	//	such values are used as shadow or holes.
	return Fn + ( saturate(50.0 * Fn) - Fn ) * pow(2, (-5.55473 * c - 6.98316)*c );
}

/*-----------------------------------------------------------------------------
	Geometry attenuation term :
-----------------------------------------------------------------------------*/

float GTerm ( float roughness, float3 N, float3 V, float3 H, float3 L ) 
{
	float	NoH	=	max( 0.0001, dot(N,H) );
	float	NoV	=	max( 0.0001, dot(N,V) );
	float	NoL	=	max( 0.0001, dot(N,L) );
	float	VoH	=	max( 0.0001, dot(V,H) );
#if 0
	float	g1	=	2 * NoH * NoV / VoH;
	float	g2	=	2 * NoH * NoL / VoH;
	float 	G	=	min(1, min(g1, g2));
	return G; 
#elif 1
	float k = roughness * sqrt(2/3.141592f);
    return ( NoL / (NoL * (1-k) + k) ) * ( NoV / (NoV * (1-k) + k) );
#else
	float a = roughness * roughness;
	float a2 = a*a;

	float G_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
	float G_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
	return saturate(rcp( G_SmithV * G_SmithL ));
#endif
}

float GTerm ( float roughness, float3 N, float3 V ) 
{
	return 1-roughness;
	float k = roughness * sqrt(2/3.141592f);
	// return 1 / (k+1) / (k+1);
	float G = 1 / (k+1) / (k+1);
	return lerp( G, 1, 0 );
	//return GTerm(roughness, N, V, 0, normalize(V*2+N) );
}


float NDF ( float roughness, float3 N, float3 H, float d )
{
	float a 	= 	roughness * roughness;
	float a2	=	a * a;
	float ndh	=	dot(N,H);
	
#if 0
	// simulate finite-size light sources:
	d	=	min( d, sqrt(1-ndh*ndh) );
	ndh	=	saturate( ndh * sqrt(1-d*d) + sqrt(1-ndh*ndh)*d );
	//	energy conservation :
	float a1		=	saturate( a + 0.66f * d );
	float factor	=	sqr( a / a1 );
	float ndh2	=	ndh * ndh;
	return factor * a2 / ( PI * sqr( ndh2 * (a2-1) + 1 ) );
#else
	float ndh2	=	ndh * ndh;
	return a2 / ( PI * sqr( ndh2 * (a2-1) + 1 ) );
#endif
}



/*-----------------------------------------------------------------------------
	Specular lighting :

	https://www.marmoset.co/toolbag/learn/pbr-theory	
	"This means that in theory conductors will not show any evidence of diffuse light. 
	In practice however there are often oxides or other residues on the surface of a 
	metal that will scatter some small amounts of light."

	http://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_slides.pdf
-----------------------------------------------------------------------------*/

float3	CookTorrance( float3 N, float3 V, float3 L, float3 I, float3 F, float roughness, float divergency )
{
			L	=	normalize(L);
			V	=	normalize(V);
	float3	H	=	normalize(V+L);
	
	float	epsilon	=	0.0009765625;
	
	float	G		=	GTerm( roughness, N,V,H,L );
	
	float	D		=	NDF( roughness, N,H, divergency );

			F		=	Fresnel( dot(V,H), F );
						  
	return max(0, I * F * D * G / (4*abs(dot(N,L))*dot(V,N)+epsilon));
}

#endif