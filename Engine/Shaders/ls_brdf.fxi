#ifndef __LS_BRDF_FXI__
#define __LS_BRDF_FXI__

#include "math.fxi"

/*------------------------------------------------------------------------------
	BRDF structures :
------------------------------------------------------------------------------*/

struct FLUX
{
	float3	intensity;		//	light intensity by R,G,B components
	float3	direction;		//	light flux direction, opposite to direction to light, normalized
	float	divergency;		//	light divergency to approximate finite size lights
	float3	direction1;		//	light flux direction, opposite to direction to light, normalized
	float	divergency1;	//	light divergency to approximate finite size lights
};

struct LIGHTING
{
	float3	emissive;
	float3	diffuse;
	float3	specular;
	float3	transmissive;
};

struct SURFACE
{
	float3	baseColor;		//	base color or albedo
	float3	normal;			//	world-space normal of the surface in given point
	float3 	emission;		//	emissive lighting component
	
	float	roughness;		//	roughness
	float	metallic;		//	metallic
	float	occlusion;		//	ambient occlusion factor
	
	float3	diffuse;		//	[derived] call ComputeDiffuseSpecular to recalc
	float3	specular;		//	[derived] call ComputeDiffuseSpecular to recalc

	float	alpha;			//	Alpha transparency
};

struct MEDIUM
{
	float3	Color;
};

struct GEOMETRY
{
	float3	position;		//	world-space position
	float3 	normal;			//	world-space geometry (vertex interpolated) normal
};


void InitLighting( out LIGHTING lighting )
{
	lighting.emissive		=	float3(0,0,0);
	lighting.diffuse		=	float3(0,0,0);
	lighting.specular		=	float3(0,0,0);
	lighting.transmissive	=	float3(0,0,0);
}

void AccumulateLighting( inout LIGHTING total, LIGHTING lighting, float scale )
{
	total.emissive		+=	lighting.emissive * scale;
	total.diffuse		+=	lighting.diffuse * scale;
	total.specular		+=	lighting.specular * scale;
	total.transmissive	+=	lighting.transmissive * scale;
}

SURFACE CreateDiffuseSurface(float3 color, float3 normal)
{
	SURFACE surf;
	surf.baseColor	=	color;
	surf.normal		=	normal;
	surf.emission	=	0;	
	surf.roughness	=	1;	
	surf.metallic	=	0;	
	surf.occlusion	=	1;	
	surf.diffuse	=	color;
	surf.specular	=	0;	
	surf.alpha		=	1;	
	return surf;
}

GEOMETRY CreateGeometry( float3 p, float3 n )
{
	GEOMETRY g;
	g.position 	= p;
	g.normal	= n;
	return g;
}

float ClampRoughness( float r )
{
	return clamp( r, 1.0f / 16.0f, 1 );
}

/*------------------------------------------------------------------------------
	BRDF functions :
------------------------------------------------------------------------------*/

float3	Lambert( float3 intensity, float3 diff_color )
{
	return intensity * diff_color / PI;
}


/*-----------------------------------------------------------------------------
	Fresnel :
-----------------------------------------------------------------------------*/

float3	Fresnel( float c, float3 Fn )
{
	//	values below 2% are not physically possible.
	//	such values are used as shadow or holes.
	return Fn + ( saturate(50.0 * Fn) - Fn ) * pow(2, (-5.55473 * c - 6.98316)*c );
}

/*-----------------------------------------------------------------------------
	Geometry attenuation term :
-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
	Specular lighting :

	https://www.marmoset.co/toolbag/learn/pbr-theory	
	"This means that in theory conductors will not show any evidence of diffuse light. 
	In practice however there are often oxides or other residues on the surface of a 
	metal that will scatter some small amounts of light."

	http://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_slides.pdf
-----------------------------------------------------------------------------*/

float D_GGX(float NoH, float a) 
{
    float a2 	=	a * a;
    float f 	=	(NoH * a2 - NoH) * NoH + 1.0;
    return a2 / (PI * f * f);
}

float3 F_Schlick(float u, float3 f0) 
{
    return f0 + (float3(1,1,1) - f0) * pow(1.0 - u, 5.0);
}

float G_SchlickBeckmann(float u, float a) 
{
	float k = a * sqrt(2/3.141592f);
    return ( u / (u * (1-k) + k) );
}

float G_GGX( float u, float a )
{
	float a2 = a*a;
	return 2 * u / ( u + sqrt(a2 + (1-a2) * u * u ) );
}

float G_Implicit(float NoV, float NoL, float a)
{
	return NoV * NoL;
}

float G_SmithGGXCorrelated(float NoV, float NoL, float a) 
{
    float a2 = a * a;
    float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
    float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
    return 0.5 / (GGXV + GGXL);
}

float G_CookTorrance(float NoV, float NoL, float NoH, float a)
{
	float g1 = 2 * (NoV * NoL)/NoH;
	float g2 = 2 * (NoV * NoL)/NoH;
	float g  = min(g1,g2);
	return min(1,g);
}

float3	CookTorrance( float3 N, float3 V, float3 L, float3 I, float3 F, float perceptualRoughness )
{
			L	=	normalize(L);
			V	=	normalize(V);
	float3	H	=	normalize(V+L);
	
	float	eps	=	1e-4f;
    float 	NoV	= 	abs  	(dot(N, V)) + eps;
    float 	NoL	= 	saturate(dot(N, L));
    float 	NoH	= 	saturate(dot(N, H));
    float 	LoH	= 	saturate(dot(L, H));	
	
    float roughness = perceptualRoughness * perceptualRoughness;

    float 	D	=	D_GGX(NoH, roughness);
			F	=	F_Schlick(LoH, F);

	// using perceptualRoughness lead to better image quality :
	// float 	G1	=	G_GGX(NoV, perceptualRoughness);
    // float 	G2	=	G_GGX(NoL, perceptualRoughness);
	// float 	G	=	G1 * G2;

	// float 	G	=	G_SmithGGXCorrelated(NoV,NoL,roughness);
	// float 	G	=	G_Implicit(NoV,NoL,roughness);
	
	//	best visual quality, and still PBR:
	float		G	=	G_CookTorrance(NoV,NoL,NoH,roughness);

	return max(0, I * F * D * G / ( 4 * NoV * NoL + eps ) );
}

#endif