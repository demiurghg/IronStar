#ifndef __LS_LIGHTING_FXI__
#define __LS_LIGHTING_FXI__

/*------------------------------------------------------------------------------
	LIGHTING
	
	LIGHTING_DIFFUSE_ONLY	--	skip specular component
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
	Lighting functions :
------------------------------------------------------------------------------*/

float LightFalloff( float dist, float max_range )
{
	float fade = 0;
	fade = saturate(1 - (dist / max_range));
	fade *= fade;
	return fade;
}


void ComputeDiffuseSpecular( inout SURFACE surface )
{
	// pow3 help to reduce white fringes in metallic PBR pipeline:
	float3  insulatorF0	=	float3(0.04f,0.04f,0.04f);
	surface.diffuse 	=	pow( lerp( pow(abs(surface.baseColor), 1/3.0), float3(0,0,0),                		 surface.metallic ), 3 );
	surface.specular  	=	pow( lerp( pow(abs(insulatorF0		), 1/3.0), pow(abs(surface.baseColor), 1/3.0f),  surface.metallic ), 3 );
}


void ComputeDiffuseOnly( inout SURFACE surface )
{
	surface.specular	=	0;
	surface.diffuse		=	surface.baseColor;
}


FLUX ComputeDirectLightFlux( DIRECT_LIGHT directLight )
{
	FLUX flux;
	flux.direction	=	normalize(directLight.DirectLightDirection.xyz);
	flux.intensity	=	directLight.DirectLightIntensity.xyz;
	flux.divergency	=	0.03f; // #TODO - angular size
	return flux;
}


FLUX ComputePointLightFlux( GEOMETRY geometry, LIGHT light, SHADOW_RESOURCES rc )
{
	uint type 	= 	light.LightType & 0x0000FFFF;
	uint shape	= 	light.LightType & 0xFFFF0000;	
	
	float3 position		=	light.PositionRadius.xyz;
	float  radius		=	light.PositionRadius.w;
	float3 intensity	=	light.IntensityFar.rgb;
	float  sourceRadius	=	light.SourceRadius;
	float3 lightDir		= 	geometry.position - position;
	float  falloff		= 	LightFalloff( length(lightDir), radius );
	float2 smSizeRcp	=	1.0f / GetTextureSize( rc.ShadowMap );
		
	FLUX flux;
	flux.direction		=	normalize( lightDir );
	flux.intensity		=	intensity * falloff;
	flux.divergency		=	1 * sourceRadius / (0.01 + length(lightDir)); 
	
	[branch]
	if (type==LightTypeOmni) 
	{
		//	TODO : IES profiles
	} 
	else if (type==LightTypeSpotShadow) 
	{
		flux.intensity		*=	ComputeSpotShadow( geometry, light, rc, true );
	}
	
	return flux;
}


float4 TubeLight( float3 lightDirNorm, float3 viewReflectNorm, float roughness, float divergency )
{
	float  	a				=	roughness * roughness;
	float 	a1				=	saturate( a + 0.66f * divergency );
	float  	energyFactor	=	sqr( a / a1 );
	
	float3 	lightToRay		=	( viewReflectNorm - lightDirNorm );
	float	lightToRayLen	=	min( length( lightToRay ), divergency );
	float3 	lightDirFS		=	normalize( viewReflectNorm - lightDirNorm ) * lightToRayLen + lightDirNorm;
	
	return float4( lightDirFS, energyFactor );
}


float3	ComputeLighting( FLUX flux, GEOMETRY geometry, SURFACE surface, CAMERA camera, bool diffuse=true, bool specular=true )
{
	float3	viewDir		=	normalize( Camera.CameraPosition.xyz - geometry.position.xyz );
	float3 	lightDir	=	-flux.direction;
	float3	viewReflect	=	reflect(-viewDir, surface.normal);
	float  	nDotL		= 	saturate( dot(surface.normal, lightDir) );
	float  	nDotLGeom	= 	saturate( dot(geometry.normal, lightDir) * 10 );
			nDotL		*=	nDotLGeom;
	
	float3	totalLight	=	0;
	
	if (diffuse)
	{
		totalLight.rgb 		+= 	nDotL * Lambert ( flux.intensity, surface.diffuse );
	}

	#ifndef LIGHTING_DIFFUSE_ONLY	
	if (specular)
	{
		float  roughness	=	ClampRoughness( surface.roughness );
		float4 tubeLight	=	TubeLight( lightDir, viewReflect, roughness, flux.divergency );
		totalLight.rgb 		+= 	nDotL * CookTorrance( surface.normal.xyz, viewDir, tubeLight.xyz, flux.intensity * tubeLight.w, surface.specular, roughness, flux.divergency );
	}
	#endif
	
	return totalLight;
}


float3	ComputeLighting( FLUX flux, GEOMETRY geometry, float3 albedo )
{
	float3 	lightDir	=	-flux.direction;
	float  	nDotL		= 	max( 0, dot(geometry.normal, lightDir) - 1.0f / 255.0f );
	
	return 	nDotL * Lambert ( flux.intensity, albedo );
}


float3	ComputeLighting( FLUX flux, GEOMETRY geometry, MEDIUM medium, CAMERA camera )
{
	float scatter	=	1.0f;
	float a 		= 	1.0f - 0.5f*scatter;
	float b 		= 	1.0f - a;
	
	return flux.intensity
			* max( 0, dot( -flux.direction, geometry.normal ) * a + b )
			* medium.Color;
}


#endif