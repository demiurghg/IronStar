#ifndef __LS_LIGHTING_FXI__
#define __LS_LIGHTING_FXI__

/*------------------------------------------------------------------------------
	LIGHTING
	
	LIGHTING_DIFFUSE_ONLY	--	skip specular component
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
	Lighting functions :
------------------------------------------------------------------------------*/

float LightFalloff( float dist, float max_range )
{
	float fade = 0;
	fade = saturate(1 - (dist / max_range));
	fade *= fade;
	return fade;
}

void ComputeDiffuseSpecular( inout SURFACE surface )
{
	// pow3 help to reduce white fringes in metallic PBR pipeline:
	float3  insulatorF0	=	float3(0.04f,0.04f,0.04f);
	surface.diffuse 	=	pow( lerp( pow(abs(surface.baseColor), 1/3.0), float3(0,0,0),                		 surface.metallic ), 3 );
	surface.specular  	=	pow( lerp( pow(abs(insulatorF0		 ), 1/3.0), pow(abs(surface.baseColor), 1/3.0f),  surface.metallic ), 3 );
}

void ComputeDiffuseOnly( inout SURFACE surface )
{
	surface.specular	=	0;
	surface.diffuse		=	surface.baseColor;
}

/*------------------------------------------------------------------------------
	Tube light support :
------------------------------------------------------------------------------*/

float3 ClosestToPoint( float3 L, float3 r, float radius)
{
	// r must be normalized
	float3	centerToRay		=	dot(L,r)*r-L;
	float3	closestPoint	=	L + centerToRay * saturate( radius / length(centerToRay) );
	return closestPoint;
}

float4 ComputeDiffuseTubeMRP( float3 L0, float3 L1, float3 n, float r )
{
	float 	a 	=	length( L0 );
	float 	b 	=	length( L1 );
	float 	t 	=	a / (b+a);
	float3 	mrp	=	L0 + t*(L1-L0);
	
	float	factor	=	1 / (1 + r / max(0.001f,length(mrp)));
	
	return float4( ClosestToPoint( mrp, n, r ), factor );
}

#pragma warning( disable : 4008 )

float4 ComputeSpecularTubeMRP( float3 L0, float3 L1, float3 normal, float3 view, float radius, float roughness )
{
	float3	R		=	normalize( reflect(-normalize(view), normal) );
	float3 	Ld		=	L1 - L0;
	
	float 	t_num 	=	dot(R, L0) * dot(Ld, R) - dot(Ld, L0);
	float 	t_denom =	dot(Ld, Ld) - dot(Ld, R) * dot(Ld, R);//*/
	float 	t 		=	saturate(t_num / t_denom);	
	float3	L		=	L0 + t * Ld;
	
	float	a		=	roughness * roughness;
	float 	a1		=	saturate( a + 0.3333f * radius / length(L) );
	float  	factor	=	sqr( a / a1 );

	return float4( ClosestToPoint( L, R, radius ), factor );
}


/*------------------------------------------------------------------------------
	Omni/Spot Lights :
------------------------------------------------------------------------------*/

LIGHTING ComputePointLight( LIGHT light, CAMERA camera, GEOMETRY geometry, SURFACE surface, SHADOW_RESOURCES rc )
{
	LIGHTING lighting = (LIGHTING)0;
	
	uint type 	= 	light.LightType & 0x0000FFFF;
	uint shape	= 	light.LightType & 0xFFFF0000;	
	
	float3	viewDir		=	camera.CameraPosition.xyz - geometry.position;
	float3 	position0	=	light.Position0LightRange.xyz;
	float3 	position1	=	light.Position1TubeRadius.xyz;
	float  	lightRange	=	light.Position0LightRange.w;
	float  	tubeRadius	=	light.Position1TubeRadius.w;
	float3 	intensity	=	light.IntensityFar.rgb;
	
	float3 	lightDir0	= 	position0 - geometry.position;
	float3 	lightDir1	= 	position1 - geometry.position;
		
	float	roughness	=	ClampRoughness( surface.roughness );
	
	float4 	diffuseMPR	=	ComputeDiffuseTubeMRP( lightDir0, lightDir1, surface.normal, tubeRadius );
	float4 	specularMRP	=	ComputeSpecularTubeMRP( lightDir0, lightDir1, surface.normal, viewDir, tubeRadius, roughness );
	float3 	lightDir	=	diffuseMPR.xyz;
	
	float	falloff		=	LightFalloff( length(lightDir), lightRange );
	float	nDotL		=	saturate( dot( surface.normal, normalize( lightDir ) ) );
	float	nDotLSpec	=	saturate( dot( surface.normal, normalize( specularMRP.xyz ) ) );
	
	float3 	shadow		=	float3(1,1,1);

	[branch]
	if (type==LightTypeOmni) 
	{
		//	TODO : IES profiles
	} 
	else if (type==LightTypeSpotShadow) 
	{
		shadow	=	ComputeSpotShadow( geometry, light, rc );
	}

	lighting.diffuse	=	shadow * nDotL * falloff * Lambert( intensity * diffuseMPR.w, surface.diffuse );
	
	lighting.specular	=	shadow * nDotLSpec * falloff * CookTorrance( surface.normal.xyz, viewDir, specularMRP.xyz, intensity * specularMRP.w, surface.specular, roughness );
	
	return lighting;
}

/*------------------------------------------------------------------------------
	Directional/Sun Light :
------------------------------------------------------------------------------*/

LIGHTING ComputeDirectLight( DIRECT_LIGHT directLight, CAMERA camera, GEOMETRY geometry, SURFACE surface, CASCADE_SHADOW cascadeShadow, SHADOW_RESOURCES rc, float2 vpos )
{
	LIGHTING lighting 	= 	(LIGHTING)0;
	
	float3	shadow		=	ComputeCascadedShadows( geometry, vpos, cascadeShadow, rc ); 
	
	float3	viewDir		=	camera.CameraPosition.xyz - geometry.position;
	float3 	lightDir	=	normalize(-directLight.DirectLightDirection.xyz);
	float3 	intensity	=	directLight.DirectLightIntensity.xyz;
	float	angularSize	=	directLight.DirectLightAngularSize;
	
	float	roughness	=	ClampRoughness( surface.roughness );
	
	float4 	specularMRP	=	ComputeSpecularTubeMRP( lightDir, lightDir, surface.normal, viewDir, angularSize, roughness );

	float	nDotL		=	saturate( dot( surface.normal, lightDir ) );

	lighting.diffuse	=	shadow * nDotL * Lambert( intensity, surface.diffuse );
	
	lighting.specular	=	shadow * nDotL * CookTorrance( surface.normal.xyz, viewDir, specularMRP.xyz, intensity * specularMRP.w, surface.specular, roughness );
	
	return lighting;
}

#endif