#ifndef __LS_LIGHTING_FXI__
#define __LS_LIGHTING_FXI__

/*------------------------------------------------------------------------------
	LIGHTING
	
	LIGHTING_DIFFUSE_ONLY	--	skip specular component
------------------------------------------------------------------------------*/

/*------------------------------------------------------------------------------
	Lighting functions :
------------------------------------------------------------------------------*/

float LightFalloff( float dist, float max_range )
{
	float fade = 0;
	fade = saturate(1 - (dist / max_range));
	fade *= fade;
	return fade;
}


void ComputeDiffuseSpecular( inout SURFACE surface )
{
	// pow3 help to reduce white fringes in metallic PBR pipeline:
	float3  insulatorF0	=	float3(0.04f,0.04f,0.04f);
	surface.diffuse 	=	pow( lerp( pow(abs(surface.baseColor), 1/3.0), float3(0,0,0),                		 surface.metallic ), 3 );
	surface.specular  	=	pow( lerp( pow(abs(insulatorF0		), 1/3.0), pow(abs(surface.baseColor), 1/3.0f),  surface.metallic ), 3 );
}


void ComputeDiffuseOnly( inout SURFACE surface )
{
	surface.specular	=	0;
	surface.diffuse		=	surface.baseColor;
}


FLUX ComputeDirectLightFlux( DIRECT_LIGHT directLight )
{
	FLUX flux;
	flux.intensity		=	directLight.DirectLightIntensity.xyz;
	flux.direction		=	normalize(directLight.DirectLightDirection.xyz);
	flux.divergency		=	0.03f; // #TODO - angular size
	flux.direction1		=	normalize(directLight.DirectLightDirection.xyz);
	flux.divergency1	=	0.03f; // #TODO - angular size
	return flux;
}


FLUX ComputePointLightFlux( GEOMETRY geometry, LIGHT light, SHADOW_RESOURCES rc )
{
	uint type 	= 	light.LightType & 0x0000FFFF;
	uint shape	= 	light.LightType & 0xFFFF0000;	
	
	float3 position		=	light.Position0LightRange.xyz;
	float3 position1	=	light.Position1TubeRadius.xyz;
	float  radius		=	light.Position0LightRange.w;
	float  tubeRadius	=	light.Position1TubeRadius.w;

	float3 intensity	=	light.IntensityFar.rgb;

	float3 lightDir0	= 	geometry.position - position;
	float3 lightDir1	= 	geometry.position - position1;
	float3 avgDir		=	0.5f * lightDir0 + 0.5f * lightDir1;
	float  falloff		= 	LightFalloff( length(avgDir), radius );
	float2 smSizeRcp	=	1.0f / GetTextureSize( rc.ShadowMap );
		
			
	FLUX flux;
	flux.intensity		=	intensity * falloff;
	flux.direction		=	normalize( lightDir0 );
	flux.direction1		=	normalize( lightDir1 );
	flux.divergency		=	1 * tubeRadius / (0.01 + length(lightDir0)); 
	flux.divergency1	=	1 * tubeRadius / (0.01 + length(lightDir1)); 
	
	[branch]
	if (type==LightTypeOmni) 
	{
		//	TODO : IES profiles
	} 
	else if (type==LightTypeSpotShadow) 
	{
		flux.intensity		*=	ComputeSpotShadow( geometry, light, rc, true );
	}
	
	return flux;
}


float4 TubeLight( float3 L0, float3 L1, float d0, float d1, float3 R, float r )
{
	float3 	Ld	=	L1 - L0;
	//float 	t	=	saturate( (dot(L0, Ld) * dot(R, L0) - dot(L0, L0) * dot(R, Ld)) / ( dot(L0, Ld) * dot(R, Ld) - dot(Ld, Ld) * dot(R, L0) + 0.00001 ) );
	
	float t_num 	=	dot(R, L0) * dot(Ld, R) - dot(Ld, L0);
	float t_denom 	=	dot(Ld, Ld) - dot(Ld, R) * dot(Ld, R);
	float t 		=	saturate(t_num / t_denom);	


	float3	L	=	L0 + t * Ld;
	float 	d	=	lerp( d0,d1,t );

	float  	a				=	r * r; // roughness^2
	float 	a1				=	saturate( a + 0.66f * d );
	float  	energyFactor	=	sqr( a / a1 ) * (a/a1);
	
	float3 	lightToRay		=	( R - L );
	float	lightToRayLen	=	min( length( lightToRay ), d );
	float3 	lightDirFS		=	normalize( R - L ) * lightToRayLen + L;
	
	return float4( lightDirFS, energyFactor );
}


float3	ComputeLighting( FLUX flux, GEOMETRY geometry, SURFACE surface, CAMERA camera, bool diffuse=true, bool specular=true )
{
	float3	viewDir		=	normalize( Camera.CameraPosition.xyz - geometry.position.xyz );
	float3 	lightDir0	=	-flux.direction;
	float3 	lightDir1	=	-flux.direction1;
	float3 	lightDir	=	0.5f * (lightDir0 + lightDir1);
	float3	viewReflect	=	reflect(-viewDir, surface.normal);
	float  	nDotL		= 	saturate( dot(surface.normal, lightDir) );
	float  	nDotLGeom	= 	saturate( dot(geometry.normal, lightDir) * 10 );
			nDotL		*=	nDotLGeom;
	
	float3	totalLight	=	0;
	
	if (diffuse)
	{
		totalLight.rgb 		+= 	nDotL * Lambert ( flux.intensity, surface.diffuse );
	}

	#ifndef LIGHTING_DIFFUSE_ONLY	
	if (specular)
	{
		float  roughness	=	ClampRoughness( surface.roughness );
		float4 tubeLight	=	TubeLight( lightDir0, lightDir1, flux.divergency, flux.divergency1, viewReflect, roughness );
		totalLight.rgb 		+= 	nDotL * CookTorrance( surface.normal.xyz, viewDir, tubeLight.xyz, flux.intensity * tubeLight.w, surface.specular, roughness );
	}
	#endif
	
	return totalLight;
}


float3	ComputeLighting( FLUX flux, GEOMETRY geometry, float3 albedo )
{
	float3 	lightDir	=	-flux.direction;
	float  	nDotL		= 	max( 0, dot(geometry.normal, lightDir) - 1.0f / 255.0f );
	
	return 	nDotL * Lambert ( flux.intensity, albedo );
}


float3	ComputeLighting( FLUX flux, GEOMETRY geometry, MEDIUM medium, CAMERA camera )
{
	float scatter	=	1.0f;
	float a 		= 	1.0f - 0.5f*scatter;
	float b 		= 	1.0f - a;
	
	return flux.intensity
			* max( 0, dot( -flux.direction, geometry.normal ) * a + b )
			* medium.Color;
}


#endif