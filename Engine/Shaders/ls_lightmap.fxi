#ifndef __LS_LIGHTMAP_FXI__
#define __LS_LIGHTMAP_FXI__

#include "shl1.fxi"

struct LIGHTMAP_RESOURCES
{
	SamplerState		Sampler;
	Texture2D<float4>	IrradianceMapL0;
	Texture2D<float4>	IrradianceMapL1;
	Texture2D<float4>	IrradianceMapL2;
	Texture2D<float4>	IrradianceMapL3;
	Texture3D<float4>	IrradianceVolumeL0;
	Texture3D<float4>	IrradianceVolumeL1;
	Texture3D<float4>	IrradianceVolumeL2;
	Texture3D<float4>	IrradianceVolumeL3;
};

static const float GI_SCALE = 3.1415f;


float3 	EvaluateSHL( float3 shL0, float3 shL1, float3 shL2, float3 shL3, GEOMETRY geometry, SURFACE surface, CAMERA camera )
{
	float3	normal	=	normalize(surface.normal);
	float3 	light	=	0;
	
	//	specular approximation :
	float3 	luma	=	float3(0.3,0.5,0.2);
	float3	dir		=	float3( dot(shL3,luma), dot(shL1,luma), dot(shL2,luma) );
	float	len		=	length(dir) + 0.001f;
			dir		=	-dir / len;
			
	float roughness	=	surface.roughness;
			
	surface.roughness	=	lerp( surface.roughness, 1, (1-len) );
			
	FLUX flux;
	flux.direction	=	dir;
	flux.intensity	=	shL0;
	light			+=	ComputeLighting( flux, geometry, surface, Camera, false, true );
	
	//	diffuse SH evaluation :
	shL1	*=	shL0;
	shL2	*=	shL0;
	shL3	*=	shL0;
	
	float4	irrR	=	float4( shL0.r, shL1.r, shL2.r, shL3.r );
	float4	irrG	=	float4( shL0.g, shL1.g, shL2.g, shL3.g );
	float4	irrB	=	float4( shL0.b, shL1.b, shL2.b, shL3.b );
	
	float	lightR	=	EvalSHL1Smooth( irrR, normal );
	float	lightG	=	EvalSHL1Smooth( irrG, normal );
	float	lightB	=	EvalSHL1Smooth( irrB, normal );
	
	light			+=	float3( lightR, lightG, lightB ) * surface.diffuse * GI_SCALE;
	
	return light;
}


float3	EvaluateLightmap ( LIGHTMAP_RESOURCES lightmap, GEOMETRY geometry, SURFACE surface, CAMERA camera, float2 lightMapCoord )
{
	float3 	shL0	=	lightmap.IrradianceMapL0.SampleLevel( lightmap.Sampler, lightMapCoord, 0 ).rgb;
	float3 	shL1	=	lightmap.IrradianceMapL1.SampleLevel( lightmap.Sampler, lightMapCoord, 0 ).rgb * 2 - 1;
	float3 	shL2	=	lightmap.IrradianceMapL2.SampleLevel( lightmap.Sampler, lightMapCoord, 0 ).rgb * 2 - 1;
	float3 	shL3	=	lightmap.IrradianceMapL3.SampleLevel( lightmap.Sampler, lightMapCoord, 0 ).rgb * 2 - 1;

	return EvaluateSHL( shL0, shL1, shL2, shL3, geometry, surface, Camera );
}


float3	EvaluateLightVolume ( LIGHTMAP_RESOURCES lightmap, GEOMETRY geometry, SURFACE surface, CAMERA camera, float3 volumeCoord )
{
	float3 	shL0	=	lightmap.IrradianceVolumeL0.SampleLevel( lightmap.Sampler, volumeCoord, 0 ).rgb;
	float3 	shL1	=	lightmap.IrradianceVolumeL1.SampleLevel( lightmap.Sampler, volumeCoord, 0 ).rgb * 2 - 1;
	float3 	shL2	=	lightmap.IrradianceVolumeL2.SampleLevel( lightmap.Sampler, volumeCoord, 0 ).rgb * 2 - 1;
	float3 	shL3	=	lightmap.IrradianceVolumeL3.SampleLevel( lightmap.Sampler, volumeCoord, 0 ).rgb * 2 - 1;

	return EvaluateSHL( shL0, shL1, shL2, shL3, geometry, surface, Camera );
}

float3	EvaluateLightVolume ( LIGHTMAP_RESOURCES lightmap, GEOMETRY geometry, SURFACE surface, CAMERA camera, uint3 voxelIndex )
{
	float3 	shL0	=	lightmap.IrradianceVolumeL0[ voxelIndex ].rgb;
	float3 	shL1	=	lightmap.IrradianceVolumeL1[ voxelIndex ].rgb * 2 - 1;
	float3 	shL2	=	lightmap.IrradianceVolumeL2[ voxelIndex ].rgb * 2 - 1;
	float3 	shL3	=	lightmap.IrradianceVolumeL3[ voxelIndex ].rgb * 2 - 1;

	return EvaluateSHL( shL0, shL1, shL2, shL3, geometry, surface, Camera );
}


#endif