#ifndef __LS_LIGHTMAP_FXI__
#define __LS_LIGHTMAP_FXI__

#include "shl1.fxi"

struct LIGHTMAP_RESOURCES
{
	SamplerState		Sampler;
	Texture2D<float4>	IrradianceMapL0;
	Texture2D<float4>	IrradianceMapL1;
	Texture2D<float4>	IrradianceMapL2;
	Texture2D<float4>	IrradianceMapL3;
	Texture3D<float4>	IrradianceVolumeL0;
	Texture3D<float4>	IrradianceVolumeL1;
	Texture3D<float4>	IrradianceVolumeL2;
	Texture3D<float4>	IrradianceVolumeL3;
};

static const float GI_SCALE = 3.1415f;


LIGHTING EvaluateSHL( float3 shL0, float3 shL1, float3 shL2, float3 shL3, float reflectionAmount, GEOMETRY geometry, SURFACE surface, CAMERA camera )
{
	float3		normal	=	normalize(surface.normal);
	LIGHTING 	light	=	(LIGHTING)0;
	
	//	specular approximation :
	float3 	luma	=	float3(0.3,0.5,0.2);
	float3	dir		=	float3( dot(shL3,luma), dot(shL1,luma), dot(shL2,luma) );
	float	len		=	length(dir) + 0.001f;
			dir		=	dir / len;
			
	float 	roughness	=	lerp( surface.roughness, 1, saturate(1 - len * len) );
	
	float3 	viewDir		=	normalize( camera.CameraPosition.xyz - geometry.position.xyz );
	float	nDotL		=	saturate( dot( normal, dir ) );
	light.specular		=	nDotL * CookTorrance( normal, viewDir, dir, shL0.rgb, surface.specular, roughness ) * 4 * 3.1415 * (1-reflectionAmount); 
	
	//	diffuse SH evaluation :
	shL1	*=	shL0;
	shL2	*=	shL0;
	shL3	*=	shL0;
	
	float4	irrR	=	float4( shL0.r, shL1.r, shL2.r, shL3.r );
	float4	irrG	=	float4( shL0.g, shL1.g, shL2.g, shL3.g );
	float4	irrB	=	float4( shL0.b, shL1.b, shL2.b, shL3.b );
		
	float	lightR	=	EvalSHL1Smooth( irrR, normal );
	float	lightG	=	EvalSHL1Smooth( irrG, normal );
	float	lightB	=	EvalSHL1Smooth( irrB, normal );
	
	light.diffuse	=	float3( lightR, lightG, lightB ) * surface.diffuse;
	
	return light;
}


LIGHTING	EvaluateLightmap ( float reflectionAmount, LIGHTMAP_RESOURCES lightmap, GEOMETRY geometry, SURFACE surface, CAMERA camera, float2 lightMapCoord )
{
	float3 	shL0	=	lightmap.IrradianceMapL0.SampleLevel( lightmap.Sampler, lightMapCoord, 0 ).rgb;
	float3 	shL1	=	lightmap.IrradianceMapL1.SampleLevel( lightmap.Sampler, lightMapCoord, 0 ).rgb * 2 - 1;
	float3 	shL2	=	lightmap.IrradianceMapL2.SampleLevel( lightmap.Sampler, lightMapCoord, 0 ).rgb * 2 - 1;
	float3 	shL3	=	lightmap.IrradianceMapL3.SampleLevel( lightmap.Sampler, lightMapCoord, 0 ).rgb * 2 - 1;

	return EvaluateSHL( shL0, shL1, shL2, shL3, reflectionAmount, geometry, surface, Camera );
}


LIGHTING	EvaluateLightVolume ( float reflectionAmount, LIGHTMAP_RESOURCES lightmap, GEOMETRY geometry, SURFACE surface, CAMERA camera, float3 volumeCoord )
{
	float3 	shL0	=	lightmap.IrradianceVolumeL0.SampleLevel( lightmap.Sampler, volumeCoord, 0 ).rgb;
	float3 	shL1	=	lightmap.IrradianceVolumeL1.SampleLevel( lightmap.Sampler, volumeCoord, 0 ).rgb * 2 - 1;
	float3 	shL2	=	lightmap.IrradianceVolumeL2.SampleLevel( lightmap.Sampler, volumeCoord, 0 ).rgb * 2 - 1;
	float3 	shL3	=	lightmap.IrradianceVolumeL3.SampleLevel( lightmap.Sampler, volumeCoord, 0 ).rgb * 2 - 1;

	return EvaluateSHL( shL0, shL1, shL2, shL3, reflectionAmount, geometry, surface, Camera );
}

LIGHTING	EvaluateLightVolume ( LIGHTMAP_RESOURCES lightmap, GEOMETRY geometry, SURFACE surface, CAMERA camera, uint3 voxelIndex )
{
	float3 	shL0	=	lightmap.IrradianceVolumeL0[ voxelIndex ].rgb;
	float3 	shL1	=	lightmap.IrradianceVolumeL1[ voxelIndex ].rgb * 2 - 1;
	float3 	shL2	=	lightmap.IrradianceVolumeL2[ voxelIndex ].rgb * 2 - 1;
	float3 	shL3	=	lightmap.IrradianceVolumeL3[ voxelIndex ].rgb * 2 - 1;

	return EvaluateSHL( shL0, shL1, shL2, shL3, 0, geometry, surface, Camera );
}


#endif