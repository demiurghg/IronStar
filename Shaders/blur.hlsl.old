
#if 0
$ubershader 	GAUSSIAN PASS1|PASS2
#endif

//-----------------------------------------------------------------------------

#include "blur.auto.hlsl"

//-----------------------------------------------------------------------------

float GaussDistribution( float x, float sigma )
{
	return 1 / (sqrt(2*3.141592f*sigma*sigma)) * exp( -(x*x) / (2*sigma*sigma) );
}


//-----------------------------------------------------------------------------

#ifdef GAUSSIAN

SamplerState		sampler	: register(s0);
Texture2D<float4> 	source  : register(t0); 
RWTexture2D<float4> target  : register(u0); 

#ifdef PASS1
groupshared half3 buffer[BlockSize*2][BlockSize];
#endif

#ifdef PASS2
groupshared half3 buffer[BlockSize][BlockSize*2];
#endif

[numthreads(BlockSize,BlockSize,1)] 
void CSMain( 
	uint3 groupId : SV_GroupID, 
	uint3 groupThreadId : SV_GroupThreadID, 
	uint  groupIndex: SV_GroupIndex, 
	uint3 dispatchThreadId : SV_DispatchThreadID) 
{
	int2 globalPos		=	dispatchThreadId.xy;
	int2 localPos		=	groupThreadId.xy;
	int2 blockPos		=	groupId.xy * BlockSize;
	int2 blockSize		=	int2(BlockSize,BlockSize);
	uint threadCount 	= 	BlockSize * BlockSize; 
	int blockOffset		=	BlockSize / 2;
	
	uint width, height, mips;
	
	source.GetDimensions( 0, width, height, mips );
	
#ifdef PASS1
	int2 readPoint0  = int2( blockPos.x + localPos.x*2 + 0 - blockOffset,  blockPos.y + localPos.y );
	int2 readPoint1  = int2( blockPos.x + localPos.x*2 + 1 - blockOffset,  blockPos.y + localPos.y );
	int2 writePoint0 = int2( localPos.x * 2 + 0, localPos.y );
	int2 writePoint1 = int2( localPos.x * 2 + 1, localPos.y );
	
	readPoint0	=	clamp( readPoint0, int2(0,0), int2(width,height) );
	readPoint1	=	clamp( readPoint1, int2(0,0), int2(width,height) );
	
	buffer[ writePoint0.x ][ writePoint0.y ] = source[ readPoint0 ].rgb;
	buffer[ writePoint1.x ][ writePoint1.y ] = source[ readPoint1 ].rgb;

	GroupMemoryBarrierWithGroupSync();
	
	float3 accum = 0;
	
	for (int x=-7; x<7; x++) {
		float weight = GaussDistribution( x, 2.0f );
		accum += buffer[ blockOffset + x + localPos.x ][ localPos.y ] * weight;
	}
	
	target[ globalPos ] = float4(accum, 1);
#endif
	
#ifdef PASS2
	int2 readPoint0  = int2( blockPos.x + localPos.x, blockPos.y + localPos.y*2 + 0 - blockOffset );
	int2 readPoint1  = int2( blockPos.x + localPos.x, blockPos.y + localPos.y*2 + 1 - blockOffset );
	int2 writePoint0 = int2( localPos.x, localPos.y * 2 + 0 );
	int2 writePoint1 = int2( localPos.x, localPos.y * 2 + 1 );
	
	readPoint0	=	clamp( readPoint0, int2(0,0), int2(width-1,height-1) );
	readPoint1	=	clamp( readPoint1, int2(0,0), int2(width-1,height-1) );
	
	buffer[ writePoint0.x ][ writePoint0.y ] = source[ readPoint0 ].rgb;;
	buffer[ writePoint1.x ][ writePoint1.y ] = source[ readPoint1 ].rgb;;

	GroupMemoryBarrierWithGroupSync();
	
	float3 accum = 0;
	
	for (int y=-7; y<7; y++) {
		float weight = GaussDistribution( y, 2.0f );
		accum += buffer[ localPos.x ][ blockOffset + y + localPos.y ] * weight;
	}
	
	target[ globalPos ] = float4(accum, 1);
#endif
	
}

#endif
