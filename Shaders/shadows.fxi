
static float2 poisonDisk[16] = {
	float2( 0.6471434f,  0.5442180f),
	float2( 0.6627925f, -0.0145980f),
	float2( 0.2094653f,  0.6861125f),
	float2( 0.01836824f, 0.1938052f),
	float2(-0.5083427f, -0.0543112f),
	float2(-0.1876637f, -0.4905864f),
	float2( 0.2701841f, -0.1667389f),
	float2(-0.5884321f,  0.5500614f),
	
	float2( 0.5244192f, -0.7732284f),
	float2( 0.1206752f, -0.9527515f),
	float2(-0.2352096f,  0.9127740f),
	float2(-0.9525819f,  0.2960428f),
	float2( 0.8872142f, -0.4135098f),
	float2(-0.9452454f, -0.1600218f),
	float2(-0.6495278f, -0.4626486f),
	float2(-0.4085272f, -0.8579809f)
};

static const float dither[4][4] = {{1,9,3,11},{13,5,15,7},{4,12,2,10},{16,8,14,16}};

float Dither ( int xpos, int ypos )
{
	return dither[xpos%4][ypos%4]/16.0f;
}


float ProjectShadow ( float3 worldPos, float4x4 viewProjection, out float4 projection )
{	
	float4 temp = 	mul( float4(worldPos,1), viewProjection );
	temp.xy 	/= 	temp.w;
	temp.w   	= 	1;
	
	projection	=	temp;

	return max(abs(temp.x), abs(temp.y));
}


float3	ComputeCSM ( 
	float2 vpos,
	float3 normal,
	float3 worldPos, 
	STAGE stage, 
	SamplerComparisonState shadowSampler, 
	SamplerState linearSampler, 
	Texture2D csmTexture, 
	Texture2D particleShadow, 
	bool useFilter )
{
	float4	projection		= float4(0,0,0,0);
	float4	bestProjection 	= float4(0,0,0,0);
	float4	bestScaleOffset = float4(0,0,0,0);
	float4 	colorize   		= float4(1,0,2,1);
	float 	radius			= 1;
	
	float	bias			= 0.90 + Dither( vpos.x, vpos.y ) / 32.0f;
	
	worldPos += normal * 0.2f;

	//	select cascade :
	if ( ProjectShadow( worldPos, stage.CascadeViewProjection3, projection ) < bias ) {
		bestProjection 	= projection;
		bestScaleOffset	= stage.CascadeScaleOffset3;
		colorize		= float4(0,0,1,1);
		radius 			= 1/pow(2.5,3);
	}
	
	if ( ProjectShadow( worldPos, stage.CascadeViewProjection2, projection ) < bias ) {
		bestProjection 	= projection;
		bestScaleOffset	= stage.CascadeScaleOffset2;
		colorize		= float4(0,1,0,1);
		radius 			= 1/pow(2.5,2);
	}
	
	if ( ProjectShadow( worldPos, stage.CascadeViewProjection1, projection ) < bias ) {
		bestProjection 	= projection;
		bestScaleOffset	= stage.CascadeScaleOffset1;
		colorize		= float4(1,0,0,1);
		radius 			= 1/pow(2.5,1);
	}
	
	if ( ProjectShadow( worldPos, stage.CascadeViewProjection0, projection ) < bias ) {
		bestProjection 	= projection;
		bestScaleOffset	= stage.CascadeScaleOffset0;
		colorize		= float4(1,1,1,1);
		radius 			= 1/pow(2.5,0);
	}

	//	compute UVs 
	float2	csmSize;
	float2	csmSizeRcp;
	csmTexture.GetDimensions( csmSize.x, csmSize.y );
	
	csmSizeRcp.xy	=	1 / csmSize.xy;

	float2	uv		=	mad( bestProjection.xy, bestScaleOffset.xy, bestScaleOffset.zw );
	float   z  		= 	projection.z;
	float3	shadow	=	0;
	
	// Poisson disk radius for 16 taps.
	radius *= 1; 
	
	if (true) {
		for( float row = -2; row <= 2; row += 1 ) {
			[unroll]for( float col = -2; col <= 2; col += 1 ) {
				float 	x	=	row;
				float	y	=	col;
				float	sh	=	csmTexture.SampleCmpLevelZero( shadowSampler, uv + csmSizeRcp * float2(x,y), z ).r;
				shadow		+=	sh;
			}
		}
		
		shadow /= 25;

		shadow *= particleShadow.SampleLevel( linearSampler, uv, 0 ).rgb;
		
	} else {
		shadow = csmTexture.SampleCmpLevelZero( shadowSampler, uv, z );
	}
	//shadow = 1;
	return shadow;// * lerp(colorize, float3(1,1,1), 0.7f);
}

